\section{Step 3: Contour Method (CM) Simulation}
\label{sec:guide_cm}

\textbf{Goal:} Generate INP files, run Abaqus jobs, extract ODB results, and convert them to XDMF/HDF5.

\subsection{Action: Execution}

Run from the project root (choose the experiment):

\begin{lstlisting}[language=bash]
# Experiment 1 -- run full pipeline (sim + conversion)
python scripts/e1_simulation_run.py cm --all

# Experiment 2
python scripts/e2_simulation_run.py cm --all
\end{lstlisting}

\textbf{Phase flags} (can be combined):
\begin{table}[ht]
\centering
\begin{tabular}{ll}
\hline
\textbf{Flag} & \textbf{Effect} \\
\hline
\texttt{--sim}  & Geometry generation + Abaqus job submission only. \\
\texttt{--conv} & ODB extraction + NPY-to-XDMF conversion only. \\
\texttt{--all}  & Both simulation and conversion phases. \\
\hline
\end{tabular}
\end{table}

With no arguments the script enters \textbf{interactive mode}, presenting numbered menus for pipeline and phase selection.

\subsection{What Happens Internally}
\begin{enumerate}
    \item \texttt{ClearDirectory} removes stale results from \texttt{cm\_directory}.
    \item \texttt{ParameterGenerator} builds the DOE matrix from \texttt{data/config.json}.
    \item \texttt{GeometryGenerator} launches Abaqus CAE (\texttt{noGUI}) with \texttt{cma/script.py} (Exp1) or \texttt{cma2/script.py} (Exp2) per parameter set.
    \item \texttt{ContourProcessor} applies polynomial boundary conditions to every mesh.
    \item \texttt{INPRunner} submits all jobs.
    \item \texttt{ResultConverter} extracts ODB data and converts to XDMF/HDF5.
\end{enumerate}

\subsection{Result Verification}

\textbf{Generated Outputs} (inside \texttt{cm\_directory}):
\begin{itemize}
    \item \texttt{*.xdmf} and \texttt{*.h5} --- one pair per DOE case, ready for the viewer.
    \item \texttt{*.odb} --- Abaqus output databases.
\end{itemize}

The terminal displays progress logs such as \texttt{[INFO] Processing Case: Mesh-0\_8--Length-50...}.