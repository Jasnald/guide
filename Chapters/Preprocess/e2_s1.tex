\section{Stage 1: Data Ingestion and Alignment}
\label{sec:exp2_stage1}

\textbf{Script:} \texttt{s1\_Outline\_process.py} (Milling Variant)

Unlike the T-shape samples, the milling profile analysis requires the synchronization of two distinct measurement passes: Left (L) and Right (R). Due to the physical nature of the scanning process, these datasets often represent opposing traversal directions and require geometric alignment before averaging.

\subsection{L/R Pairing and Directional Correction}

The script operates on the \texttt{Sample\_og/Milling Samples} directory. It identifies corresponding sample pairs by parsing folder names matching the pattern \texttt{Sample<N>L} and \texttt{Sample<N>R} (e.g., \texttt{12L} and \texttt{12R}).

The function \texttt{calc\_average\_and\_save\_json} implements a specific alignment algorithm to handle the inverted scan directions:

\begin{enumerate}
    \item \textbf{Data Truncation:} 
    To ensure matrix compatibility, both datasets are trimmed to the length of the shortest file ($\min(N_L, N_R)$).

    \item \textbf{Array Reversal (Mirroring):} 
    The "Left" sample is treated as the reference frame. The "Right" sample is aligned to this reference by taking its \textit{last} $N$ points and reversing their order. This corrects the spatial inversion caused by the bi-directional scanning:
    \begin{lstlisting}[language=Python]
# s1_Outline_process.py
paired_L = data_L[:min_len]
paired_R = data_R[::-1][:min_len]  # Reverse slice
    \end{lstlisting}

    \item \textbf{Composite Averaging:} 
    The final point cloud is generated by calculating the arithmetic mean of the aligned arrays:
    \begin{equation}
        P_{avg} = \frac{P_{aligned\_L} + P_{aligned\_R}}{2}
    \end{equation}
\end{enumerate}

\subsection{Progressive Statistical Cleaning (IQR)}

After alignment, the data is subjected to an iterative cleaning process via \texttt{run\_iterative\_iqr}. Unlike the single-pass approach used in some workflows, this module employs a **progressive tightening strategy** to preserve edge fidelity while removing noise.

The Interquartile Range (IQR) filter is applied sequentially with decreasing tolerance factors, defined in \texttt{iqr\_params\_per\_iteration}:

\begin{table}[ht]
\centering
\begin{tabular}{|c|c|l|}
\hline
\textbf{Iteration} & \textbf{Factor (k)} & \textbf{Purpose} \\ \hline
1 & 1.5 & Removal of gross outliers (large spikes) \\ \hline
2 & 1.0 & General noise reduction \\ \hline
3 & 0.9 & Fine filtering of profile edges \\ \hline
\end{tabular}
\caption{Progressive IQR thresholds for milling profiles}
\label{tab:exp2_iqr}
\end{table}

A point is only retained if it satisfies the condition $Q_1 - k \cdot IQR \leq x \leq Q_3 + k \cdot IQR$ simultaneously for all active dimensions (X, Y, Z).