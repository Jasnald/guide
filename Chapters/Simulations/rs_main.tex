\chapter{Residual Stress Analysis (RSA) Workflow}
\label{ch:ch_rs_workflow}

\textbf{Pipeline scripts:}
\begin{itemize}
    \item \texttt{src/simulations/e1\_rs\_pipeline.py} --- Experiment 1 (T-shape)
    \item \texttt{src/simulations/e2\_rs\_pipeline.py} --- Experiment 2 (block / milling)
\end{itemize}
\textbf{CAE scripts:}
\begin{itemize}
    \item \texttt{src/simulations/rsa/script.py} --- Exp1 RSA builder
    \item \texttt{src/simulations/rsa2/script.py} --- Exp2 RSA builder
\end{itemize}

Both pipelines follow the shared two-phase pattern described in Chapter~\ref{ch:workflow_pattern}. Unlike the Contour Method workflow, RSA has two additional concerns: a \emph{strict dependency on CMA results} and a \emph{stress-mapping bridge} that runs between mesh generation and job submission.

% ─────────────────────────────────────────────────────────────
\section{CMA Dependency}
\label{sec:rsa_cma_dep}

Each RSA pipeline accepts a \texttt{run\_cma} flag. When \texttt{True}, the script imports and calls the corresponding CM pipeline (\texttt{e1\_cm\_pipeline.main()} or \texttt{e2\_cm\_pipeline.main()}) before starting its own workflow. This guarantees that the HDF5 files containing the measured stress fields are up to date.

% ─────────────────────────────────────────────────────────────
\section{RSA-Specific Phase 1: Stress Mapping and IC Injection}
\label{sec:rsa_phase1}

After mesh generation (Step~3 of the shared pattern), the RSA pipeline executes two extra sub-steps before job submission:

\subsection{Stress Mapping (ElementProcess Bridge)}
\label{sec:rsa_stress_mapping}

\begin{lstlisting}[language=Python]
Nodes_main(str(config.rea_directory), use_s1=True, use_s2=False, use_s3=False)
proc = StressProcessor(str(config.rea_directory), tolerance=5e-2, chunk_size=10000)
proc.process_all_simulations(str(cm_hdf5_path))
\end{lstlisting}

\texttt{Nodes\_main} extracts element centroids from the RSA mesh; \texttt{StressProcessor} maps $S_{33}$ from the CMA HDF5 files onto those centroids using 2D KDTree (see Chapter~\ref{sec:ep_datadriven}). For Experiment~2, \texttt{StressProcessorBatch} replaces \texttt{StressProcessor} to handle the multi-case (\texttt{S1\_}, \texttt{S2\_}, \ldots) directory layout (see Chapter~\ref{sec:ep_batch_variant}).

\subsection{Initial-Condition Injection}

\texttt{ResidualProcessor(config).run\_batch()} injects \texttt{*Initial Conditions} blocks into every \texttt{.inp} file before solver submission.

% ─────────────────────────────────────────────────────────────
\section{RSA-Specific Phase 2: Result Conversion}
\label{sec:rsa_conversion}

\begin{itemize}
    \item \texttt{ResultConverter.run\_pipeline(method\_type="Residual\_Stresses\_Analysis", script\_module="rsa")} --- ODB extraction via \texttt{rsa/conv.py}, then NPY-to-XDMF compilation.
\end{itemize}

\begin{quote}
\textbf{Note:} \texttt{rsa2} does \textbf{not} have a \texttt{conv.py} file. Result conversion for Exp2 RSA reuses the same \texttt{rsa/conv.py} extraction script.
\end{quote}

% ─────────────────────────────────────────────────────────────
\section{Multi-Step Physics}
\label{sec:rsa_multistep}

Unlike the single-step CM workflow, every RSA CAE script creates a \textbf{three-step} analysis sequence, each with \texttt{previous} chained to the prior step:

\begin{enumerate}
    \item \textbf{Material-Removal:} \texttt{ModelChangeSetter} deactivates the ``Remove'' element set, simulating the physical cut.
    \item \textbf{BC-Removal:} Removes the encastre BC applied below the $y$-cutoff ($y < h_{avg}/8$), allowing the part to deform.
    \item \textbf{BC-Removal\_Nodes:} Releases pinned nodal BCs at $y < 0$ and applies final node displacement constraints via \texttt{\_bc\_node.setI()} (Exp1) or \texttt{\_bc\_node.setII()} (Exp2).
\end{enumerate}

% ─────────────────────────────────────────────────────────────
\section{Plane Settings and Extra Initialisation}
\label{sec:rsa_plane_settings}

Beyond the standard \texttt{BaseAnalysis} constructor, \texttt{ResidualAnalysis} performs two additional initialisation steps:

\begin{enumerate}
    \item \textbf{Plane settings:} \texttt{\_load\_plane\_settings()} reads the experiment's JSON file (\texttt{data/e1\_plane\_settings.json} or \texttt{data/e2\_plane\_settings.json}) to obtain the ZX and ZY cutting-plane coordinates. These are stored in \texttt{self.selected\_planes} (consumed by \texttt{\_rm\_datum}) and \texttt{self.remove\_region}.
    \item \textbf{Extra propagation:} \texttt{self.propagate\_to(\_rm\_datum, \_rm\_region, \_sets)} pushes the plane coordinates and region info into the geometry-setup services.
\end{enumerate}

% ─────────────────────────────────────────────────────────────
\section{Overridden \texttt{run\_analysis()}}
\label{sec:rsa_run_override}

\texttt{ResidualAnalysis} overrides \texttt{BaseAnalysis.run\_analysis()} to insert two extra calls:
\begin{itemize}
    \item \texttt{self.\_sets.setI()} (or \texttt{setII()} for Exp2) --- creates named element/node sets required by the BC definitions, inserted after mesh generation.
    \item \texttt{self.t\_part.generateMesh()} --- a second mesh generation after boundary conditions are applied, ensuring the final partitioned mesh is consistent.
\end{itemize}

% ─────────────────────────────────────────────────────────────
\section{Experiment Comparison}
\label{sec:rsa_exp_comparison}
\label{sec:rsa_script}

Both CAE scripts define \texttt{ResidualAnalysis(BaseAnalysis)}. The per-experiment differences are:

\begin{table}[ht]
\centering
\begin{tabular}{lp{5.2cm}p{5.2cm}}
\hline
\textbf{Aspect} & \textbf{Experiment 1 (T-shape)} & \textbf{Experiment 2 (Block)} \\
\hline
Geometry script    & \texttt{rsa/script.py}  & \texttt{rsa2/script.py} (overridden at runtime) \\
Geometry class     & \texttt{GeometrySetter} (\texttt{sim\_one}) & \texttt{GeometrySetterTwo} (\texttt{sim\_two}) \\
Stress mapper      & \texttt{StressProcessor} (single-case) & \texttt{StressProcessorBatch} (multi-case \texttt{S1\_}, \texttt{S2\_}, \ldots) \\
CAE class          & \texttt{ResidualAnalysis(BaseAnalysis)} & \texttt{ResidualAnalysis(BaseAnalysis)} \\
Plane settings     & Resolved internally from \texttt{data/e1\_plane\_settings.json} & Explicit \texttt{plane\_settings\_path} argument; default \texttt{data/e2\_plane\_settings.json} \\
Step names         & Inline string literals & Module-level \texttt{STEP\_NAMES} tuple \\
Sets / BCs         & \texttt{\_sets.setI()}, \texttt{\_bc\_node.setI()} & \texttt{\_sets.setII()}, \texttt{\_bc\_node.setII()} \\
Partitions         & \texttt{\_invt\_mesh\_part.set()} + datum planes & Datum planes only (no \texttt{\_invt\_mesh\_part}) \\
Result conversion  & \texttt{rsa/conv.py} & Reuses \texttt{rsa/conv.py} (no \texttt{rsa2/conv.py}) \\
\hline
\end{tabular}
\caption{Per-experiment differences in the RSA workflow.}
\label{tab:rsa_comparison}
\end{table}