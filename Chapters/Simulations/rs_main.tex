\chapter{Residual Stress Analysis (RSA) Workflow}
\label{ch:ch_rs_workflow}

\textbf{Pipeline scripts:}
\begin{itemize}
    \item \texttt{src/simulations/e1\_rs\_pipeline.py} --- Experiment 1 (T-shape)
    \item \texttt{src/simulations/e2\_rs\_pipeline.py} --- Experiment 2 (block / milling)
\end{itemize}
\textbf{CAE scripts:}
\begin{itemize}
    \item \texttt{src/simulations/rsa/script.py} --- Exp1 RSA builder
    \item \texttt{src/simulations/rsa2/script.py} --- Exp2 RSA builder
\end{itemize}

Both pipelines follow the shared two-phase pattern described in Chapter~\ref{ch:workflow_pattern}. The \texttt{main(run\_cma, run\_rsa, convertion\_process\_rsa)} entry point adds a third boolean flag (\texttt{run\_cma}) not present in the CM pipelines. This chapter documents the three RSA-specific concerns: CMA dependency, stress-mapping injection, and multi-step CAE physics.

% ─────────────────────────────────────────────────────────────
\section{CMA Dependency}
\label{sec:rsa_cma_dep}

When \texttt{run\_cma=True}, the pipeline imports and calls the matching CM pipeline before starting its own work:

\begin{itemize}
    \item Exp1: \texttt{from simulations.e1\_cm\_pipeline import main as cma\_main}
    \item Exp2: \texttt{from simulations.e2\_cm\_pipeline import main as cma\_main}
\end{itemize}

This guarantees that the HDF5 files containing $S_{33}$ stress fields (produced by the ODB$\to$XDMF conversion in the CM pipeline) exist and are up to date before stress mapping begins.

% ─────────────────────────────────────────────────────────────
\section{RSA-Specific Phase 1: Stress Mapping and IC Injection}
\label{sec:rsa_phase1}

After mesh generation (Step~3 of the shared pattern), the RSA pipeline executes two extra sub-steps before job submission:

\subsection{Stress Mapping (ElementProcess Bridge)}
\label{sec:rsa_stress_mapping}

\begin{lstlisting}[language=Python]
Nodes_main(str(config.rea_directory), use_s1=True, use_s2=False, use_s3=False)

cm_hdf5_path = config.cm_directory / "xdmf_hdf5_files"
proc = StressProcessor(str(config.rea_directory), tolerance=5e-2, chunk_size=10000)
proc.process_all_simulations(str(cm_hdf5_path))
\end{lstlisting}

\texttt{Nodes\_main} extracts element centroids from every RSA mesh in \texttt{rea\_directory}. \texttt{StressProcessor} then maps $S_{33}$ from the CMA HDF5 files onto those centroids using a 2-D KDTree lookup (see Chapter~\ref{sec:ep_datadriven}). For Experiment~2, \texttt{StressProcessorBatch} replaces \texttt{StressProcessor} to handle the multi-case (\texttt{S1\_}, \texttt{S2\_}, \ldots) directory layout produced by the batch CM run (see Chapter~\ref{sec:ep_batch_variant}).

\subsection{Initial-Condition Injection}

\texttt{ResidualProcessor(config).run\_batch()} injects \texttt{*Initial Conditions} blocks into every \texttt{.inp} file, encoding the mapped stress field as element-level pre-stress before solver submission.

% ─────────────────────────────────────────────────────────────
\section{RSA-Specific Phase 2 Note}
\label{sec:rsa_conversion}

Result conversion uses the shared \texttt{ResultConverter} mechanism (see Table~\ref{tab:result_converter_args} in Chapter~\ref{ch:workflow_pattern}).

\begin{quote}
\textbf{Note:} \texttt{rsa2/} does \textbf{not} contain a \texttt{conv.py} file. Exp2 RSA result conversion reuses \texttt{rsa/conv.py} via \texttt{script\_module="rsa"}.
\end{quote}

% ─────────────────────────────────────────────────────────────
\section{Multi-Step Physics}
\label{sec:rsa_multistep}

Unlike the single-step CM workflow, every RSA CAE script creates a \textbf{three-step} analysis sequence, each with \texttt{previous} chained to the prior step:

\begin{enumerate}
    \item \textbf{Material-Removal:} \texttt{ModelChangeSetter} deactivates the \texttt{Remove} element set (\texttt{modelChangeName='Machining'}), simulating the physical cut.
    \item \textbf{BC-Removal:} Deactivates the encastre BC that was applied to nodes below $y < h_{\text{avg}}/8$ (via \texttt{\_blw\_bc} with \texttt{remove=True}).
    \item \textbf{BC-Removal\_Nodes:} Releases pinned nodal BCs at $y < 0$ and applies final node displacement constraints via \texttt{\_bc\_node.setI()} (Exp1) or \texttt{\_bc\_node.setII()} (Exp2).
\end{enumerate}

Exp1 defines the step names as instance attributes in \texttt{\_\_init\_\_}; Exp2 defines them at module level as \texttt{STEP\_NAMES = ('Material-Removal', 'BC-Removal', 'BC-Removal\_Nodes')}.

% ─────────────────────────────────────────────────────────────
\section{Plane Settings and Extra Initialisation}
\label{sec:rsa_plane_settings}

Beyond the standard \texttt{BaseAnalysis} constructor, \texttt{ResidualAnalysis.\_\_init\_\_} performs two additional initialisation steps:

\begin{enumerate}
    \item \textbf{Plane settings:} \texttt{\_load\_plane\_settings()} reads the experiment's cutting-plane JSON (\texttt{data/e1\_plane\_settings.json} or \texttt{data/e2\_plane\_settings.json}) via \texttt{PlaneGetter}. The ZX and ZY cutting-plane coordinates are stored in \texttt{self.selected\_planes} and \texttt{self.remove\_region}, plus scalar shortcuts \texttt{self.ZX} / \texttt{self.ZY}.
    \item \textbf{Propagation:} \texttt{self.propagate\_to(\_rm\_datum, \_rm\_region, \_sets)} pushes the plane coordinates and region info into the geometry-setup services consumed by \texttt{\_setup\_partitions} and \texttt{\_setup\_boundary\_conditions}.
\end{enumerate}

% ─────────────────────────────────────────────────────────────
\section{Overridden \texttt{run\_analysis()}}
\label{sec:rsa_run_override}

\texttt{ResidualAnalysis} overrides \texttt{BaseAnalysis.run\_analysis()} to insert extra calls around the standard pipeline. The modified execution order is:

\begin{enumerate}
    \item \texttt{self.first\_stage()} --- inherited geometry setup.
    \item \texttt{self.\_setup\_partitions()} --- datum planes (and mesh partitions for Exp1).
    \item \texttt{self.\_mesh.mesh()} --- initial mesh generation.
    \item \texttt{self.\_sets.setI()} (Exp1) or \texttt{self.\_sets.setII()} (Exp2) --- creates named element/node sets required by the BC definitions.
    \item \texttt{self.\_setup\_steps()} --- creates the three analysis steps.
    \item \texttt{self.\_setup\_boundary\_conditions()} --- encastre, model change, pinned BCs, node BCs.
    \item \texttt{self.t\_part.generateMesh()} --- a second mesh generation after BCs are applied, ensuring the final partitioned mesh is consistent.
    \item \texttt{self.\_job.create\_and\_move\_job()} --- writes the INP file.
\end{enumerate}

% ─────────────────────────────────────────────────────────────
\section{Experiment Comparison}
\label{sec:rsa_exp_comparison}
\label{sec:rsa_script}

Both CAE scripts define \texttt{ResidualAnalysis(BaseAnalysis)}. The per-experiment differences are:

\begin{table}[ht]
\centering
\begin{tabular}{lp{5.0cm}p{5.0cm}}
\hline
\textbf{Aspect} & \textbf{Experiment 1 (T-shape)} & \textbf{Experiment 2 (Block)} \\
\hline
Geometry script    & \texttt{rsa/script.py} (default) & \texttt{rsa2/script.py} (overridden at runtime) \\
Geometry class     & \texttt{GeometrySetter()} & \texttt{GeometrySetterTwo()} \\
Shape accessor     & \texttt{ShapeGetterI().t\_shape()} & \texttt{ShapeGetterII().t\_shape()} \\
Stress mapper      & \texttt{StressProcessor} & \texttt{StressProcessorBatch} (multi-case \texttt{S1\_}, \texttt{S2\_}\ldots) \\
Plane settings     & Resolved internally; \texttt{data/e1\_plane\_settings.json} & Explicit constructor arg \texttt{plane\_settings\_path}; defaults to \texttt{data/e2\_plane\_settings.json} \\
Step names         & Instance attributes & Module-level \texttt{STEP\_NAMES} tuple \\
Below-cutoff BC    & \texttt{bc\_type='EncastreBC'} (explicit) & Default \texttt{bc\_type} (not set explicitly) \\
Sets / Node BCs    & \texttt{\_sets.setI()}, \texttt{\_bc\_node.setI()} & \texttt{\_sets.setII()}, \texttt{\_bc\_node.setII()} \\
Partitions         & \texttt{\_rm\_datum.set()} + \texttt{\_invt\_mesh\_part.set()} & \texttt{\_rm\_datum.set()} only \\
Result conversion  & \texttt{rsa/conv.py} & Reuses \texttt{rsa/conv.py} (no \texttt{rsa2/conv.py}) \\
\hline
\end{tabular}
\caption{Per-experiment differences in the RSA CAE scripts and pipelines.}
\label{tab:rsa_comparison}
\end{table}