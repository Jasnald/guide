\section{Execution Wrappers}
\label{sec:inp_execution}

\textbf{Script:} \texttt{runners.py}

This module bridges the gap between the Python data structures and the external Abaqus solver. It abstracts the complexity of command-line invocation, process management, and batch reporting.

\subsection{Single Job Execution}
\textbf{Class:} \texttt{AbaqusJobRunner}

This class handles the execution of a single simulation job. It is designed to be robust on Windows environments where path handling can be problematic.
\begin{itemize}
    \item \textbf{Command Construction:} 
    The method \texttt{\_build\_command\_string} constructs the exact CLI string required by the Abaqus driver. It handles:
    \begin{lstlisting}[language=Bash]
    abaqus job=JobName input="Path With Spaces.inp" cpus=4 memory=90 scratch="C:/Temp"
    \end{lstlisting}
    It ensures all paths are correctly quoted to prevent errors.
    
    \item \textbf{Resource Management:} 
    It translates the configuration object (from \texttt{dataclasses.py}) into solver flags, setting CPU affinity and memory limits dynamically.
    
    \item \textbf{Scratch Handling:} 
    If enabled, it automatically creates and assigns a scratch directory for temporary solver files, keeping the main output directory clean.
\end{itemize}

\subsection{Abaqus Script Runner}
\textbf{Class:} \texttt{AbaqusScriptRunner}

Executes standalone Abaqus Python scripts (as opposed to full solver jobs). Key detail: it handles \textbf{UNC paths} (e.g., \texttt{\textbackslash\textbackslash server\textbackslash share}) transparently by wrapping the call in \texttt{pushd}/\texttt{popd}, which maps the UNC path to a temporary drive letter before execution and unmaps it afterwards.

\subsection{Batch Orchestration}
\textbf{Class:} \texttt{INPRunner}

Manages the execution of multiple input files in sequence.
\begin{itemize}
    \item \textbf{Discovery:} \texttt{find\_inp\_files(pattern)} scans \texttt{base\_dir} recursively using a glob pattern. Default pattern is \texttt{**/*\_FI.inp}.
    \item \textbf{Success Detection:} A job is considered successful only if the return code is \texttt{0} \textit{and} the corresponding \texttt{.odb} file was produced in the output directory. A zero return code without an ODB file is treated as a failure.
    \item \textbf{Reporting:} After the batch, a \texttt{summary\_report.txt} is written to \texttt{simulation\_logs/} containing job name, status (OK/ERROR), wall-clock time, and a truncated error message for each file.
\end{itemize}