\section{Simulation Processors (Business Logic)}
\label{sec:pl_processors}

\textbf{Script:} \texttt{processors.py}

Implements the experiment-specific logic for modifying input files. Two dedicated classes cover the two simulation workflows.

\subsection{Contour Method Processor}
\textbf{Class:} \texttt{ContourProcessor}

Applies polynomial boundary conditions derived from experimental surface measurements.

\begin{itemize}
    \item \textbf{\texttt{\_extract\_sample\_id(filename)}:} Static helper that normalises JSON filenames to a sample prefix. Recognises formats \texttt{Sample4.json}, \texttt{S4.json}, and \texttt{4.json}, all resolving to \texttt{S4}. Used to prefix the output filename (e.g., \texttt{S4\_Mesh-0\_60--Length-50\_FI.inp}).

    \item \textbf{\texttt{calculate\_z\_robust(params, x, y, degree)}:} Static method that evaluates the polynomial $Z = P(x, y)$ at a node coordinate. Automatically detects the polynomial format:
    \begin{itemize}
        \item \textbf{1D (univariate in Y):} \texttt{len(params) == degree + 1}.
        \item \textbf{2D (bivariate in X, Y):} \texttt{len(params) == 2\,*\,degree + 1} â€” alternating $a_k$ (X) and $b_k$ (Y) terms plus a constant.
    \end{itemize}

    \item \textbf{\texttt{run\_batch}:} Supports two modes:
    \begin{itemize}
        \item \textbf{Batch mode (default):} Matches each JSON in \texttt{polynomial\_json\_dir} to every base \texttt{.inp} in \texttt{cm\_directory}. Files ending in \texttt{\_Raw.json} are excluded.
        \item \textbf{Single mode} (\texttt{use\_default\_single\_file=True}): Applies \texttt{polynomial\_json\_default} to all meshes.
    \end{itemize}
    For each pair, it reads the displacement node set (\texttt{nset\_disp\_name}; falls back to $z=0$ nodes), generates \texttt{BCGenerator} lines, updates the material block, and fixes restart frequency.
\end{itemize}

\subsection{Residual Stress Processor}
\textbf{Class:} \texttt{ResidualProcessor}

Applies pre-computed residual stresses as \texttt{*Initial Conditions, type=STRESS} to the RSA mesh files.

\begin{itemize}
    \item \textbf{Discovery:} Scans \texttt{rea\_directory/Output/} for subdirectories that contain a \texttt{stress\_input.txt} file (default; configurable via \texttt{csv\_filename}). Each such subdirectory is a \textit{case} (e.g., \texttt{S1\_Mesh-0\_60--Length-50\_FI}).

    \item \textbf{Mesh resolution:} Strips \texttt{\_FI} suffix and any \texttt{S\textit{N}\_} prefix via regex (\texttt{r"\^{}S\textbackslash{}d+\_(.+)\$"}) to obtain the base mesh name, then looks for the corresponding \texttt{.inp} in \texttt{rea\_directory}.

    \item \textbf{Output location:} The generated \texttt{\_FI.inp} file is written to \texttt{rea\_directory} (not inside the case subdirectory) so all Abaqus run artefacts (\texttt{.odb}, \texttt{.sta}, \texttt{.msg}) remain together.

    \item \textbf{Injection workflow:} \texttt{StressReader} $\to$ \texttt{ElsetGenerator} $\to$ \texttt{InitialStressGenerator} $\to$ \texttt{INPInserter.insert\_elsets} $\to$ \texttt{INPInserter.insert\_initial\_stresses} $\to$ \texttt{INPInserter.replace\_material\_block} $\to$ \texttt{INPInserter.fix\_restart\_frequency} $\to$ \texttt{INPWriter}.
\end{itemize}