\section{Results Conversion Pipeline}
\label{sec:pl_conversion}

\textbf{Script:} \texttt{converters.py}

While the \texttt{Conversor} module (Part I) contains the low-level logic for handling data formats, this script acts as the high-level trigger within the automation pipeline. It orchestrates the multi-stage process of transforming proprietary Abaqus results into open formats.

\subsection{Two-Stage Execution}
The \texttt{ResultConverter} class manages the bridge between the different Python environments required for extraction:

\begin{enumerate}
    \item \textbf{ODB Extraction (Abaqus Python 2.7):} 
    The method \texttt{\_run\_abaqus\_extraction(script\_module)} locates \texttt{conv.py} inside the given sub-module folder (e.g., \texttt{src/simulations/cma/conv.py}) and invokes it via the Abaqus Python interpreter using \texttt{AbaqusScriptRunner}. This extracts raw field data from \texttt{.odb} files into \texttt{.npy} files.
    
    \item \textbf{XDMF Compilation (Python 3.x):} 
    Immediately after extraction, \texttt{\_run\_npy\_to\_xdmf} instantiates \texttt{NPY2XDMFParameters} with the \texttt{method\_type} and \texttt{target\_dir\_key} arguments to resolve the correct source and destination directories. It then runs \texttt{NpyBatchToXdmfConverter} to compile the raw arrays into hierarchical HDF5/XDMF files.
\end{enumerate}

\subsection{Pipeline Integration}
This converter is designed to be called at the end of a simulation workflow (e.g., inside \texttt{cm\_main.py}). It takes a \texttt{method\_type} string (e.g., \texttt{"Contour\_Method"}) and a \texttt{target\_dir\_key} to correctly route the output files to their specific directories.