\chapter{Contour Method Simulation Workflow}
\label{ch:ch_cm_workflow}

\textbf{Pipeline scripts:}
\begin{itemize}
    \item \texttt{src/simulations/e1\_cm\_pipeline.py} --- Experiment 1 (T-shape)
    \item \texttt{src/simulations/e2\_cm\_pipeline.py} --- Experiment 2 (block / milling)
\end{itemize}
\textbf{CAE scripts:}
\begin{itemize}
    \item \texttt{src/simulations/cma/script.py} --- Exp1 geometry builder
    \item \texttt{src/simulations/cma2/script.py} --- Exp2 geometry builder
\end{itemize}

Both pipelines follow the shared two-phase pattern described in Chapter~\ref{ch:workflow_pattern}. The \texttt{main(default\_process, convertion\_process)} entry point controls the two phases via boolean flags. This chapter documents only the CM-specific behaviour: how displacement boundary conditions are injected (Phase~1 Step~4) and how the two CAE scripts differ.

% ─────────────────────────────────────────────────────────────
\section{CM-Specific Phase 1: Boundary-Condition Injection}
\label{sec:cm_bc_injection}

After mesh generation (Step~3 of the shared pattern), \texttt{ContourProcessor(config).run\_batch()} reads polynomial surface-fit JSON files and writes their displacement data onto the mesh nodes, producing \texttt{\_FI.inp} files. The operating mode depends on the experiment:

\begin{itemize}
    \item \textbf{Single-file mode} (Exp1): \texttt{run\_batch(use\_default\_single\_file=True)} applies one default polynomial JSON to all meshes.
    \item \textbf{Batch mode} (Exp2): \texttt{run\_batch()} (no flag) iterates over every JSON in \texttt{polynomial\_json\_dir} (excluding \texttt{\_Raw.json}), producing an \texttt{S\textit{N}\_Mesh-\ldots-\_FI.inp} per mesh/polynomial combination.
\end{itemize}

% ─────────────────────────────────────────────────────────────
\section{CM Step Topology}
\label{sec:cm_steps}

Both \texttt{cma/script.py} and \texttt{cma2/script.py} create a single analysis step:
\begin{itemize}
    \item \texttt{Step-1} (Static, General) with \texttt{previous = 'Initial'}.
\end{itemize}
All step parameters (\texttt{initialInc}, \texttt{maxInc}, \texttt{maxNumInc}, \texttt{minInc}, \texttt{nlgeom}, \texttt{time}) are inherited from the DOE dictionary injected by \texttt{ParametersGetter}.

% ─────────────────────────────────────────────────────────────
\section{Experiment Comparison}
\label{sec:cm_exp_comparison}

Both CAE scripts define \texttt{ContourAnalysis(BaseAnalysis)} and call \texttt{\_invt\_mesh\_part.set()} for partition alignment. The per-experiment differences are confined to geometry and boundary conditions:

\begin{table}[ht]
\centering
\begin{tabular}{lp{5.2cm}p{5.2cm}}
\hline
\textbf{Aspect} & \textbf{Experiment 1 (T-shape)} & \textbf{Experiment 2 (Block)} \\
\hline
Geometry script   & \texttt{cma/script.py} (default)  & \texttt{cma2/script.py} (overridden at runtime) \\
Geometry class    & \texttt{GeometrySetter()} & \texttt{GeometrySetterTwo()} \\
BC mode           & Single-file: one default polynomial JSON & Batch: every JSON $\times$ every mesh \\
CAE class         & \texttt{ContourAnalysis} & \texttt{ContourAnalysis} \\
Partitions        & \texttt{\_invt\_mesh\_part.set()} & \texttt{\_invt\_mesh\_part.set()} \\
Encastre set      & \texttt{Set\_Enc}: \texttt{zMin=comprimento} ($z \ge L$) & \texttt{Encastre-BackFace-Set}: tolerance band $z \in [L{-}0.01,\; L{+}0.01]$ \\
Encastre BC name  & \texttt{Enc\_Set\_Enc} & \texttt{BC-Encastre-Back} \\
Displacement set  & \texttt{Set\_Disp}: \texttt{zMax=0} ($z \le 0$) & \texttt{Set\_Disp}: \texttt{zMax=0} ($z \le 0$) \\
\hline
\end{tabular}
\caption{Per-experiment differences in the Contour Method CAE scripts.}
\label{tab:cm_comparison}
\end{table}
