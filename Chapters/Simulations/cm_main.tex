\chapter{Contour Method Simulation Workflow}
\label{ch:ch_cm_workflow}

\textbf{Pipeline scripts:}
\begin{itemize}
    \item \texttt{src/simulations/e1\_cm\_pipeline.py} --- Experiment 1 (T-shape)
    \item \texttt{src/simulations/e2\_cm\_pipeline.py} --- Experiment 2 (block / milling)
\end{itemize}
\textbf{CAE scripts:}
\begin{itemize}
    \item \texttt{src/simulations/cma/script.py} --- Exp1 geometry builder
    \item \texttt{src/simulations/cma2/script.py} --- Exp2 geometry builder
\end{itemize}

Both pipelines follow the same two-phase pattern; the key differences are which \texttt{GeometrySetter} is used and whether Contour Method boundary conditions come from a single default JSON or from a per-sample batch.

% ─────────────────────────────────────────────────────────────
\section{Experiment 1: \texttt{e1\_cm\_pipeline.py}}
\label{sec:e1_cm}

The \texttt{main(default\_process, convertion\_process)} function loads \texttt{data/config.json} via \texttt{ConfigurationManager} and executes two optional phases:

\subsection{Phase 1 --- Simulation Setup and Execution}
Controlled by \texttt{default\_process}:

\begin{enumerate}
    \item \texttt{ClearDirectory(config.cm\_directory)} --- purges previous results.
    \item \texttt{ParameterGenerator.generate\_combinations(config)} --- creates the DOE matrix.
    \item \texttt{GeometryGenerator.run\_batch(params, cm\_directory)} --- launches Abaqus CAE (\texttt{noGUI}) with \texttt{cma/script.py} for every parameter set.
    \item \texttt{ContourProcessor(config).run\_batch(use\_default\_single\_file=True)} --- applies the default polynomial JSON to all meshes as nodal displacements.
    \item \texttt{INPRunner.run\_all(silent=True)} --- submits every \texttt{\_FI.inp} to the Abaqus solver.
\end{enumerate}

\subsection{Phase 2 --- Result Conversion}
Controlled by \texttt{convertion\_process}:
\begin{itemize}
    \item \texttt{ResultConverter.run\_pipeline(method\_type="Contour\_Method", script\_module="cma")} --- runs ODB extraction via \texttt{cma/conv.py} and then NPY-to-XDMF compilation.
\end{itemize}

% ─────────────────────────────────────────────────────────────
\section{Experiment 2: \texttt{e2\_cm\_pipeline.py}}
\label{sec:e2_cm}

Structurally identical to Exp1 with two differences:

\begin{enumerate}
    \item The geometry script is overridden at runtime:
    \begin{lstlisting}[language=Python]
config.geometry_script = _here / "cma2" / "script.py"
    \end{lstlisting}
    \item \texttt{ContourProcessor.run\_batch()} is called \textit{without} \texttt{use\_default\_single\_file}, so it operates in \textbf{batch mode}: every JSON in \texttt{polynomial\_json\_dir} (excluding \texttt{\_Raw.json}) is applied to every base mesh, producing an \texttt{S\textit{N}\_Mesh-...-\_FI.inp} per combination.
\end{enumerate}

% ─────────────────────────────────────────────────────────────
\section{CAE Script: \texttt{cma/script.py} (Exp1 Builder)}
\label{sec:cma_script}

Runs inside the Abaqus Python 2.7 kernel. Defines \texttt{ContourAnalysis(BaseAnalysis)}, which implements the four abstract methods of \texttt{BaseAnalysis}:

\begin{table}[ht]
\centering
\begin{tabular}{ll}
\hline
\textbf{Method} & \textbf{Implementation} \\
\hline
\texttt{\_get\_geometry\_setter} & Returns \texttt{GeometrySetter()} (\texttt{sim\_one}, T-shape). \\
\texttt{\_setup\_partitions}     & Calls \texttt{self.\_invt\_mesh\_part.set()} for partition alignment. \\
\texttt{\_setup\_steps}          & Creates a single \texttt{Step-1} (Static, General) with previous=\texttt{Initial}. \\
\texttt{\_setup\_boundary\_conditions} & Creates \texttt{Set\_Enc} ($z \ge L$), \texttt{Set\_Disp} ($z \le 0$), and encastre BC. \\
\hline
\end{tabular}
\caption{Abstract method implementations in \texttt{cma/script.py}.}
\end{table}

\textbf{Parameter injection:} The \texttt{GeometryGenerator} serialises the DOE dictionary into \texttt{os.environ["SIMULATION\_PARAMETERS"]}; the script reads it via \texttt{ParametersGetter()} and passes it to \texttt{BaseAnalysis.\_\_init\_\_}.

% ─────────────────────────────────────────────────────────────
\section{CAE Script: \texttt{cma2/script.py} (Exp2 Builder)}
\label{sec:cma2_script}

Same class name (\texttt{ContourAnalysis}) but uses \texttt{GeometrySetterTwo()} (block geometry from \texttt{sim\_two}). Differences from Exp1:

\begin{itemize}
    \item \textbf{Geometry:} Block cross-section instead of T-shape.
    \item \textbf{Boundary conditions:} Encastre is applied to the \textit{back face} ($z \approx L$) using a tight tolerance band (\texttt{zMin = comprimento - 0.01}, \texttt{zMax = comprimento + 0.01}). \texttt{Set\_Disp} ($z \le 0$) is created for the displacement surface.
\end{itemize}
